#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>
#include <cstring>
#include <algorithm>
#include <unistd.h>
#include <sys/stat.h>


const size_t BLOCK_SIZE = 64; 
const size_t HASH_SIZE_256 = 32; 
const size_t HASH_SIZE_512 = 64; 

// Таблица замен 
const unsigned char Pi[256] = {
    0xFC, 0xEE, 0xDD, 0x11, 0xCF, 0x6E, 0x31, 0x16, 0xFB, 0xC4, 0xFA, 0xDA, 0x23, 0xC5, 0x04, 0x4D,
    0xE9, 0x77, 0xF0, 0xDB, 0x93, 0x2E, 0x99, 0xBA, 0x17, 0x36, 0xF1, 0xBB, 0x14, 0xCD, 0x5F, 0xC1,
    0xF9, 0x18, 0x65, 0x5A, 0xE2, 0x5C, 0xEF, 0x21, 0x81, 0x1C, 0x3C, 0x42, 0x8B, 0x01, 0x8E, 0x4F,
    0x05, 0x84, 0x02, 0xAE, 0xE3, 0x6A, 0x8F, 0xA0, 0x06, 0x0B, 0xED, 0x98, 0x7F, 0xD4, 0xD3, 0x1F,
    0xEB, 0x34, 0x2C, 0x51, 0xEA, 0xC8, 0x48, 0xAB, 0xF2, 0x2A, 0x68, 0xA2, 0xFD, 0x3A, 0xCE, 0xCC,
    0xB5, 0x70, 0x0E, 0x56, 0x08, 0x0C, 0x76, 0x12, 0xBF, 0x72, 0x13, 0x47, 0x9C, 0xB7, 0x5D, 0x87,
    0x15, 0xA1, 0x96, 0x29, 0x10, 0x7B, 0x9A, 0xC7, 0xF3, 0x91, 0x78, 0x6F, 0x9D, 0x9E, 0xB2, 0xB1,
    0x32, 0x75, 0x19, 0x3D, 0xFF, 0x35, 0x8A, 0x7E, 0x6D, 0x54, 0xC6, 0x80, 0xC3, 0xBD, 0x0D, 0x57,
    0xDF, 0xF5, 0x24, 0xA9, 0x3E, 0xA8, 0x43, 0xC9, 0xD7, 0x79, 0xD6, 0xF6, 0x7C, 0x22, 0xB9, 0x03,
    0xE0, 0x0F, 0xEC, 0xDE, 0x7A, 0x94, 0xB0, 0xBC, 0xDC, 0xE8, 0x28, 0x50, 0x4E, 0x33, 0x0A, 0x4A,
    0xA7, 0x97, 0x60, 0x73, 0x1E, 0x00, 0x62, 0x44, 0x1A, 0xB8, 0x38, 0x82, 0x64, 0x9F, 0x26, 0x41,
    0xAD, 0x45, 0x46, 0x92, 0x27, 0x5E, 0x55, 0x2F, 0x8C, 0xA3, 0xA5, 0x7D, 0x69, 0xD5, 0x95, 0x3B,
    0x07, 0x58, 0xB3, 0x40, 0x86, 0xAC, 0x1D, 0xF7, 0x30, 0x37, 0x6B, 0xE4, 0x88, 0xD9, 0xE7, 0x89,
    0xE1, 0x1B, 0x83, 0x49, 0x4C, 0x3F, 0xF8, 0xFE, 0x8D, 0x53, 0xAA, 0x90, 0xCA, 0xD8, 0x85, 0x61,
    0x20, 0x71, 0x67, 0xA4, 0x2D, 0x2B, 0x09, 0x5B, 0xCB, 0x9B, 0x25, 0xD0, 0xBE, 0xE5, 0x6C, 0x52,
    0x59, 0xA6, 0x74, 0xD2, 0xE6, 0xF4, 0xB4, 0xC0, 0xD1, 0x66, 0xAF, 0xC2, 0x39, 0x4B, 0x63, 0xB6
};

// Таблица умножения в поле Галуа
const unsigned char Tau[64] = {
    0, 8, 16, 24, 32, 40, 48, 56, 1, 9, 17, 25, 33, 41, 49, 57,
    2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59,
    4, 12, 20, 28, 36, 44, 52, 60, 5, 13, 21, 29, 37, 45, 53, 61,
    6, 14, 22, 30, 38, 46, 54, 62, 7, 15, 23, 31, 39, 47, 55, 63
};

const unsigned char C[12][64] = {
    { /* C[0] */
        0xb1,0x08,0x5b,0xda,0x1e,0xca,0xda,0xe9,0xeb,0xcb,0x2f,0x81,0xc0,0x65,0x7c,0x1f,
        0x2f,0x6a,0x76,0x43,0x2e,0x45,0xd0,0x16,0x71,0x4e,0xb8,0x8d,0x75,0x85,0xc4,0xfc,
        0x4b,0x7c,0xe0,0x91,0x92,0x67,0x69,0x01,0xa2,0x42,0x2a,0x08,0xa4,0x60,0xd3,0x15,
        0x05,0x76,0x74,0x36,0xcc,0x74,0x4d,0x23,0xdd,0x80,0x65,0x59,0xf2,0xa6,0x45,0x07
    },
    { /* C[1] */
        0x93,0xd9,0x14,0x45,0x42,0xcf,0x4b,0x0e,0x0c,0x89,0x15,0x6d,0x05,0x1c,0xda,0x43,
        0x22,0xdf,0x47,0xdd,0x5f,0x58,0x46,0x50,0x8a,0xbb,0xe8,0xc1,0x72,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },
    { /* C[2] */
        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f
    },
    { /* C[3] */
        0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
        0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f
    },
    { /* C[4] */
        0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
        0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
        0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
        0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf
    },
    { /* C[5] */
        0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
        0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
    },
    { /* C[6] */
        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f
    },
    { /* C[7] */
        0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
        0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f
    },
    { /* C[8] */
        0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
        0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
        0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
        0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf
    },
    { /* C[9] */
        0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
        0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
    },
    { /* C[10] */
        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f
    },
    { /* C[11] */
        0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
        0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f
    }
};
// Линейное преобразование L
void L_transform(unsigned char* state) {
    unsigned char result[64] = { 0 };

    for (int i = 0; i < 8; ++i) {
        unsigned char v[8];
        for (int j = 0; j < 8; ++j) {
            v[j] = state[8 * i + j];
        }

        // Умножение в поле Галуа
        unsigned char tmp[8] = { 0 };
        for (int j = 0; j < 64; ++j) {
            if (v[j / 8] & (1 << (7 - (j % 8)))) {
                for (int k = 0; k < 8; ++k) {
                    tmp[k] ^= C[0][63 - j + k];
                }
            }
        }

        for (int j = 0; j < 8; ++j) {
            result[8 * i + j] = tmp[j];
        }
    }

    memcpy(state, result, 64);
}


void S_transform(unsigned char* state) {
    for (int i = 0; i < 64; ++i) {
        state[i] = Pi[state[i]];
    }
}


void P_transform(unsigned char* state) {
    unsigned char result[64];
    for (int i = 0; i < 64; ++i) {
        result[i] = state[Tau[i]];
    }
    memcpy(state, result, 64);
}


void LPS_transform(unsigned char* state) {
    S_transform(state);
    P_transform(state);
    L_transform(state);
}


void E_function(unsigned char* K, unsigned char* m, unsigned char* result) {
    unsigned char state[64];
    memcpy(state, K, 64);

    for (int i = 0; i < 12; ++i) {
        LPS_transform(state);
    }

    for (int i = 0; i < 64; ++i) {
        result[i] = state[i] ^ m[i];
    }
}


void g_function(unsigned char* h, unsigned char* N, unsigned char* m) {
    unsigned char K[64];
    memcpy(K, h, 64);

    unsigned char t[64];
    for (int i = 0; i < 64; ++i) {
        t[i] = h[i] ^ N[i];
    }

    unsigned char K1[64];
    E_function(K, t, K1);

    LPS_transform(K1);

    for (int i = 0; i < 64; ++i) {
        h[i] = K1[i] ^ m[i];
    }
}


class StribogHash {
private:
    unsigned char h[BLOCK_SIZE];
    unsigned char N[BLOCK_SIZE];
    unsigned char Sigma[BLOCK_SIZE];
    unsigned char buffer[BLOCK_SIZE];
    size_t bufferSize;
    uint64_t totalSize;
    bool is_512;

public:
    StribogHash(bool is_512bit = true) : bufferSize(0), totalSize(0), is_512(is_512bit) {
        
        if (is_512) {
            memset(h, 0x00, BLOCK_SIZE);
        }
        else {
            memset(h, 0x01, BLOCK_SIZE);
        }
        memset(N, 0x00, BLOCK_SIZE);
        memset(Sigma, 0x00, BLOCK_SIZE);
        memset(buffer, 0x00, BLOCK_SIZE);
    }

    void update(const unsigned char* data, size_t len) {
        totalSize += len;

        while (len > 0) {
            size_t toCopy = std::min(BLOCK_SIZE - bufferSize, len);
            memcpy(buffer + bufferSize, data, toCopy);
            bufferSize += toCopy;
            data += toCopy;
            len -= toCopy;

            if (bufferSize == BLOCK_SIZE) {
                processBlock();
                bufferSize = 0;
            }
        }
    }

    void processBlock() {
        
        unsigned char carry = 0;
        for (int i = 0; i < BLOCK_SIZE; ++i) {
            unsigned int sum = N[i] + (BLOCK_SIZE * 8) + carry;
            N[i] = sum & 0xFF;
            carry = sum >> 8;
        }

        
        carry = 0;
        for (int i = 0; i < BLOCK_SIZE; ++i) {
            unsigned int sum = Sigma[i] + buffer[i] + carry;
            Sigma[i] = sum & 0xFF;
            carry = sum >> 8;
        }

        
        g_function(h, N, buffer);
    }

    void final(unsigned char* hash) {
        
        if (bufferSize < BLOCK_SIZE) {
            memset(buffer + bufferSize, 0x00, BLOCK_SIZE - bufferSize - 1);
            buffer[bufferSize] = 0x01;
        }

        processBlock();

        unsigned char zeroBlock[BLOCK_SIZE] = { 0 };
        g_function(h, N, zeroBlock);
        memset(N, 0x00, BLOCK_SIZE);
        g_function(h, N, Sigma);

        
        if (is_512) {
            memcpy(hash, h, HASH_SIZE_512);
        }
        else {
            memcpy(hash, h + (HASH_SIZE_512 - HASH_SIZE_256), HASH_SIZE_256);
        }
    }
};

// Ф-я для вычисления хеша файла
void calculateFileHash(const char* filename, bool is_512bit, unsigned char* hash) {
    struct stat s;
    if (stat(filename, &s) == 0 && S_ISDIR(s.st_mode)) {
        throw std::runtime_error("Path is a directory");
    }
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Cannot open file");
    }

    StribogHash hasher(is_512bit);
    unsigned char buffer[4096];

    while (file) {
        file.read(reinterpret_cast<char*>(buffer), sizeof(buffer));
        hasher.update(buffer, file.gcount());
    }

    hasher.final(hash);
}

int main(int argc, char* argv[]) {
    std::string filename;
    char cwd[1024];
    getcwd(cwd, sizeof(cwd));
    std::cout << "[DEBUG] Current working dir: " << cwd << std::endl;
    if (argc > 1 && argv[1] && std::string(argv[1]).length() > 0) {
        std::cout << "[DEBUG] argv[1] = '" << argv[1] << "'" << std::endl;
        filename = argv[1];
    } else {
        std::cout << "Введите имя файла (Enter для sisiy.pdf): ";
        std::getline(std::cin, filename);
        if (filename.empty()) filename = "sisiy.pdf";
    }
    try {
        unsigned char hash[HASH_SIZE_512];
        calculateFileHash(filename.c_str(), true, hash);  

        std::cout << "Stribog-512 hash of " << filename << ":\n";
        for (size_t i = 0; i < HASH_SIZE_512; ++i) {
            std::cout << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(hash[i]);
        }
        std::cout << std::dec << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}